'''
0.
    class Demo:
        def t1Greedy():
        return solutionClass

        def t2Annealing():
        return solutionClass

        def t3MixesPolicy():
        return solutionClass



    class Warehouse:
        def __init__(self):
            self.openOrders = self.Orders
            self.assignedOrders = []


    class OutputStation():
        def getFeasibleBatches(self, warehouseInstance.openOrders)



    class Solution():
        '''
        a class that has the attributes described in the log_example.xml file
        solution classes are then created by the t******-methods of the Demo class and returned to the outside script.
        from there they can be expported to xml file with ET.tree
        '''
        def __init__(self):
            # load structure from xml template file






1. calculate a matrix of feasible batches for one packing station (using weight constraint 18kg). Calculate time to complete batch for each packing station.
    -- a feasible batch respects cobot capacity
    -- METHOD:  getFeasibleBatches(self, packingStationID: int) -> dict[batchID, List[OrderID]]:
                return feasibleBatchesDict
    Considerations for batch time completion calculation:
        Walking speed to get to shelves (human) 1.3 m/s
        Picking time for each item 3.0 seconds
        More than one cobot could be waiting on the same picker (this assumption seems super hard. Maybe we make optional).
        Moving speed of cobot is 2.0 m/s
        We also need to calculate the optimal route for each batch (this assumption is also super hard. We might need to come up
                                                                    with and easy solution).


Packing time:
    unload time 20 sec
    prep time 30 sec
    packing time 60 sec (this is a constraint. If the cobot gets a new batch and returns in less than 60 sec, it must wait. This
                            contraint needs to be considered when choosing the next batch for the cobot.)



2. choose from that matrix the batch that has the least time per order (or time per item) (IMPORTANT: try different choices)
    -- need method to determine the time it takes for the cobot to pick all items and return to packing station (should include waytime as well as waiting time for pickers)
    -- METHOD: batchDuration()
    -- METHOD: batchTimePerOrder() <-- used to chose the "best" batch at the time
    
3. assign the chosen batch to the packing station
    --


4. reduce the set of open orders by the orders of the assigned batch


5. move on to the next packing station and assign another feasible batch


6. after all packing stations are working, wait until any(the first) cobot comes back.
7. send it out again with the algorithm from 1-5 (calculate possible batches, assign batch based on rules, reduce set of open order)



optimizations:
we don't want to send out the robot again for a picking tour, 
that is faster than the packing time of the packer for the previously delivered order. (or add in waiting time)



'''